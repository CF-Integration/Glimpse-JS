<html>
<head>
    <meta charset="utf-8">
    <title>Reveal JS Demo - Black & White</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script>var manifest = [{"src":"https://i.imgur.com/1QfmBQQ.jpg","data":"m796d5d614:409,0Kkwggdyo+wNcypRkvhjPNHqlMgxoxgfLL9rP4JudDkgr8XqCtj4EjthgqML5c9bXKZU+Q+aSYWhOZj3RxglHt8HB82CDExAZbCZP6k32MF/YMwLT0Cm5fIFpSkg+ITdHo1bBzlNkUzcAMXgK/VglNkF/qT4Cl/u+zddXj/////swg"},{"src":"https://i.imgur.com/NiS7IEI.jpg","data":"m544d45570:375,0JTsQ5XeTdrbPtTLPLLLAPacPbTMPcLLUsb8PLLbPMPdTdKtPbTcPcPIHMP5IcHPPdg7O7X38aP5TdY7Y4GbLZ9vkgcgggaqDaCXYQcAfuc15bH5EAkfXuTeLNH38PY7PpTMDbGpCvP4HKLKH4L38bf6PMYgggfY93M8cO"},{"src":"https://i.imgur.com/2Na9toD.jpg","data":"m6b59521620:1080,0scPcPgxkfkQc8POg9YQgQgxgeUQgPcecPc8YQgfghgOPfcPgggfYhcgcggQcgg8XuY8YPY7Y8ggYhcPcekfghgvUPcDowghbuY6UAUAcdPcQ8kvgQcfcOcMY8cgYfcQXuYfc9bvf+oLcOg7cQgBgfgggfcfccPrXwggXtY6TtYPgicAUAgPYQUQowYhkfgPcPcMUOYAggTMUuZCkCg9kgkggPgfgfggYfc8YdMgggghY8U8gRovchk9gBcxgPc8gQchgucOYMUhgRk7PgcPguggXibfc7cgghXvTfcsgxcxlQgucRjubeTtUAcNPjcQXLUfkfL6UNQKXhcgnvkgc9QfTtPcLNc8MEXsPcU6TuPbYfcgggYBgicQY4IdPdM9XuUAVDUcDMP8PuGrLNLcPOMQpBlBfqHbPgY7PdQNHxY5P4QAc6D4bvgMgNYAofofPYHKU8T3D4HMITmIXcUSY9PecLUgXxgxcgkOLMM5PtKpCpHcTgvNvZYPUOftTeTfcecik9c7LObKHNCpCrTrTptOs4T4PcjZY5ULXvdPXuTLLMGpD3D5PsLrD3Fes4X4GqXMQrTsD6cPQMTbLrCrP2TLH4HaH6TkXvY3HKH3kRgdQLUwXrX5LcGqOpCZ8pD4HtIdwdU3Q4MAk9YxEeMeXMD4TJD5L38Y8qHLP9HeRJYMHBffXqbgXOfuXL8LL5H4L48YGoDMQ9I6VJc9SckOUBfoIOoOXKKpL5PKD48qCIHLLgcMLRUAScTbavobgfsQX6L4HKGpH3CYCqHMLdU6kUkvcKU8Y9cQmuQPTqHKL4CqHKCpH4LMLKkLUdixXqUfDsLwOb6uL6HKHLP5P5HKXKH4LbHaLrXpHMTekvXq8IEbH3PMLLDKLK8oauXKHePuUQYrGbjQP16gGhAdGpDRKqH5HL4cA793DNP8jtQ9QMSX4NbpI+6dKoEPWoHLLKU3E14oHbcfXMHeY9gfh2Xxh8T5LJ8Hb3L4H2HLDMKbTpcPkdTPcOLsIMUhUuM2OdUNCXX4CZD4H4L5TtgAgsbwQvcibicBY+c7PQnfGpL4L5HLLLLNL9ggY7k6ftjBlAQusscuXtgfTtTtTsLMLLPMU8gPcKYvcxR3Sxccd7cOU7U7TtXuTtTtTtTtYgcggQgPcxTILMQDg3LdfuY7TtTtTtU7U7Y8YQgeTtceTdCHX5QiPNTKjuftXtg7XuYgU8YBgQggg49LLgGKGsUfoeQ8g9cvTtXuUBnfk8cKYQghbsGoLKXP8YQLQeQ8cMcPlAg8cgUxfwkQgebt8bL2DI"},{"src":"https://i.imgur.com/WKaRvJA.jpg","data":"m2b1400670:679,0NTtTtTtS0PKH4HMTtTtTtSW00H4CpDMTtTtTt0000H4GpH6TtTtTmG0O4H4H4H7TtTtS90204H4H4HtTtTm000014H4H4TtU8W00000H4H4GtU8Xs000004CpCpDtTsPL00000pCpCpTbLGL00000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},{"src":"https://i.imgur.com/RXEY1nk.jpg","data":"m5e646e651:1200,0MLcPdTtTtTtTsPcLcTtU8Y8Y8Y7TsPdTuY8Y9cPc8Y8TtU8YPcPcPcPcPY8U8cPcggggggfcPY9cQggkxkxkwgfcOcQghkxkykxkxgfcggxlCpCpCpBkwggkxpCtTtTtCpBkwkxpDtTtTtTtSoxkypDtUxkxkxTtCoypTtkxkxkxkLTpCpDr5xkx//kL3tSpDteXV////sbJjtDtkQLV/x/uq9+xTtUwMDCdAfaDrxjtUxcX3cQkJ94VkxTxknKENULQMGkxjtk/JPtXgg28h/ktkxo8re6Kp4H7+xTxl8ZPKf3CX4UxjtkypCqhgCY4oxktUxiWZFJ734NFkxTxksdFCpRXICkxjtUxeYxexkM8YxjtTtjgiCsGZGYFUtStUjvXJGo4Y8ZtSpTseD4Co8Y8XFSpCt5g58X4HOfXSpBpBQNan8H8ZCYFBkykMP68Y4J8o8KkhkwXLKZ4o8qCYAgggX4L38J4sGo8bcggNH2H6DL928YA9c8TbCaD1GoCY8eYOTrTJKpCY8o8YU8XbPKDYCoCZ8Y9tTdPJDID18Y8Y8cPrPKGpGo8Z8Y8YLcHKKYD2CoCY8Y"},{"src":"https://i.imgur.com/MvhEZ.jpg","data":"m989086395:540,0D1uwBg9ciqExkxkxkdWwkhkvyhk3kxkxfxkuExkxkdkxWxkxkvkxk3kxkxbdUuExipENktWwyx8suu+3ipbvUcEmAdkpkxc/WlixkoEwN3kLBxkw+i9xdvjxAw0lZhkxkx628xdwExkeBwjp8xUw0xkxkVdSk"},{"src":"https://66.media.tumblr.com/9a907a73d4d2b8d500683aa0e4a6c5c4/tumblr_o4unhlCDgy1qhvtlqo1_1280.jpg","data":"m7c7c7c858:1280,0TtUxkxkxkxkxkxkxkxjtUxjxkxkxkxkxkxkxjxTtTxkxkxkxkxkxkxkxkxTxkxkxkxkxkxk/kxkxjtTxkxkxkxkxkxkxkxkxjtkxkxkxkxkxkxkxkxkxjxkxkxkxkxkxkxkxkxTxUxkxk/kxkxlxkxkxktjxkxkxkxkxkxlxkxkxkxkxkxkxkx+xkxkxkxkxkxkxkxTxkxUxkxkxkxkxUtktTtUtjtTxkxkxkxjtTtjtTtTtTtTxjxjxTtTtTtSpCpTtTtTtTtTtTtTpCpSpCpDpTtTtTtTtTpClCpCpCpCpCtTtTtTtCpAkxlCpCpCpCpTtStCpCohkxpClCpCpCpTpCpCpCghkxoykxlCpCpCpCpBkwgxkxkxoxoupCpCpBoxkgkxkxpClCLSpCtCpBkxgxlCpCpCobRSpSpCpCkvcggxkxkxcekCpCkxkxk8cQggghhkwfcALRggggY9YQcPcQlUExkwkgcPcNY8YPc9cQupggggcPcPbtY8Y9Y8cNCpcPcOYOY8Y8U8Y8U3J3DPcOY7XuTvbtU8TuWpmqH8cPY7TtTuU7TsTsDBHKD8c8Y7TsY7XtQ7PZH4CqE8Y7XtTdXvXdPfT3CpCvYObuTsPsU6XeYOCqCqXuXuTtPcTtTsU7U8H3DOTtXtPsPLLcPeY8U4GpY7PtTcPMPLLbPrTtT3GsTcPMLbLLH5LMPcPcH3HcPcPLLKH4H4H4HLLKGpPLLLL4CpD4H4H4H4H3D5LLH4H4CpH4H4H4H4KpHKH4H4H3CqGqH4HKL4H4H4H4H4H4CpCpD4H4H4H4H4GqH3GpCpCpD4H4D3GqGpH4Gp"},{"src":"https://d262ilb51hltx0.cloudfront.net/max/800/1*Eci6sHQOh1L304_t7prrSQ.jpeg","data":"m495651800:455,0RpeMRVNVwgrkzk8UhoglPm/TfCGEkvtcdMSsfgUjrd1MSn3c5o9QSojmsQhU6FRQLH6+ApQVxkYYrlJN38uDiQBPflNHeAGFMISX98oHscMwOU7aNH3XK964YSSQNoNXO5LSG9KT1142aIKgNjdbp9Z0vHIHpGpbDXZQccoLL04nXOnL5bNanTdXbX8a30bc8JJHZOoTbPcHOAPTffcIG4t8sQ5LcT11aOyfaCrT5TPLdH3CY4HL7HaCtKMDZMdfL8H4X0qCY42XdG1"}];</script>
    <style>

    html,
    body {
        margin: 0;
        text-align: center;
        padding: 2.5% 0;
    }
    
    h1 {
        font-size: 125%;
        line-height: 1.4;
        padding: 0 5%;
    }
    
    p {
        line-height: 1.6;
        text-align: left;
        max-width: 36em;
        padding: 0 5% 1em;
        display: inline-block;
    }
    
    small {
        display: block;
        margin: 0.5em 0;
        color: #aaa;
    }

    figure {
        background: #333;
        display: inline-block;
        margin: 5%;
        padding: 0;
        position: relative;
        overflow: hidden;
        vertical-align: middle;
    }

    figure:before {
        content: attr(data-tint);
        font-size: 150%;
        text-transform: uppercase;
        letter-spacing: 0.04em;
        color: white;
        width: 100%;
        margin: -0.6em 0 0;
        position: absolute;
        top: 50%;
        left: 0;
        opacity: 0;
        transition: 0.2s ease;
    }

    figure:active:before {
        opacity: 0.66;
        transition: 0.2s 0.1s ease-in;
    }
    
    figure img {
        width: auto;
        height: auto;
        max-width: 100%;
        max-height: 100%;
        display: block;
        position: relative;
        z-index: 1;
        opacity: 0;
        transition: 0.4s ease;
    }

    figure canvas {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        -ms-filter: blur(32px);
        -moz-filter: blur(32px); 
        -webkit-filter: blur(32px);
        filter: blur(32px);
    }
    
    figure:active img.loaded, figure:active canvas,
    figure:hover img.loaded,
    figure.img 
    { opacity: 0 }
    
    figure img.loaded
    { opacity: 1 }
    
    figure:active img.loaded { 
        opacity: 0;
        transition: 0.2s ease-out; 
    }

    </style>
</head>
<body>
    
    <header>
        <h1>Reveal JS Demo in Black&nbsp;&&nbsp;White</h1>
        <p>
            The combined Reveal JS data transfer-size for these images is <mark>3.03KB</mark>&nbsp;(compressed).
            Hover an image to display the preview image, press an image to see it’s average color.
            Image load times have been throttled with 100 to 800ms to emulate mediocre network speed.
            <small>Images loaded via Imgur, Tumblr, and&nbsp;Medium.</small>
        </p>
    </header>

    <script>var reveal = function(document){ "use strict";
	
	// # Initialise
	// Set a class-name when a .canvas() or .image() are used.
	var classNames = {
		base: "preview", // Added to every element
		monochrome: "monochrome", // Added to monochrome images
	};	
	
	// WARNING: Changing following variables might break the library, proceed with caution.
	var type = "image/jpeg";
	var pool = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/";
	var separateData = ",";
	var separateSize = ":";
	var tagImg 	   = "img";
	var tagCanvas  = "canvas";
	var hexPrefix  = "#";
	var monoPrefix = "m";
		
	// Generate all possible shorthand hex color combinations (#000 – #fff, 4.096 in total).
	var hexIndex = function(string){ // "0123456789ABCDEF"
		var length = string.length;
		var result = [];
		for (var a = 0; a < length; ++a){
			for (var b = 0; b < length; ++b){
				for (var c = 0; c < length; ++c){
					result.push([ string[a], string[b], string[c] ].join(""));
				}
			}
		}
		return result;
	}(pool.substr(0, 16));
	
	// Generate a two-byte key for each value in the hexIndex.
	var keyIndex = function(string){
		var length = string.length;
		var result = [];
		for (var a = 0; a < length; ++a){
			for (var b = 0; b < length; ++b){
				result.push([ string[a], string[b] ].join(""));
			}
		}
		return result;
	}(pool);
	
	// Generate a map to pair each key with its hex value and vice versa.
	var map = function(hexMap, keyMap){
		for (var i = 0; i < 4096; ++i){
			var hex = hexIndex[i], key = keyIndex[i];
			hexMap[hex] = key;
			keyMap[key] = hex;
		}
		return { hex: hexMap, key: keyMap };
	}({}, {});
	
	// Expose public methods
	return {
		create: encodeImage,
		base64: imageToBase64,
		canvas: imageToCanvas,
		image: imageToImg,
		meta: getImageMeta,
		get support(){ return !!getContext(createImage(tagCanvas)) }
	};

	
	// # Public methods
	// Load an image source URI/URL and generate a data-string from its imageData using canvas.
	function encodeImage(source, callback, quality, monochrome){
		
		var image = createImage(tagImg);
		image.onload = function(){
			
			var width  = image.naturalWidth;
			var height = image.naturalHeight;
			var scaled = resize(width, height, quality);
			var color  = null;
			
			var imageData = getData(image, scaled.width, scaled.height);
			var result = []; // Here go the keys
			var colorIndex = [ 0, 0, 0 ]; // 
			var count = 0; // 
			
			if (!monochrome){
				
				for (var i = 0, length = imageData.length; i < length; i += 4){
					
					var a = imageData[i  ];	colorIndex[0] += a;
					var b = imageData[i+1];	colorIndex[1] += b;
					var c = imageData[i+2];	colorIndex[2] += c;
					
					if (monochrome !== false) monochrome = a === b && b === c;
					result[count++] = channelToKey(a, b, c);
				
				}
				color = getAverageColor(colorIndex, count);
				
			}

			if (monochrome === true){
				
				result = [], count = 0; // reset image
				// scaled.width += 1000; // map preview width to private key-range
				var getAverage = color === null; // c
				
				for (var i = 0, length = imageData.length; i < length; i += 12){
					
					var trio = [];
					for (var pixel = 0; pixel < 12; pixel += 4){
						
						var a = imageData[i+pixel  ]; // r
						var b = imageData[i+pixel+1]; // g
						var c = imageData[i+pixel+2]; // b
						
						trio.push(Math.round((a + b + c) / 3)); // push grayscale value
						
						if (getAverage && a){
							colorIndex[0] += a; // r
							colorIndex[1] += b; // g
							colorIndex[2] += c; // b
						}
						
					}
					result[count++] = channelToKey(trio[0], trio[1], trio[2]);
					
				}
				color = getAverage ? getAverageColor(colorIndex, count * 4) : color;
				
			}
						
			// Compose the data-string and pass it to a callback function.
			result = [
				(monochrome ? monoPrefix : hexPrefix) + color, // Prefix with Average color...
				width, separateSize, height, separateData, // and dimensions.
				keyIndex[scaled.width], result.join("") // Image data
			].join("");
						
			callback(result, {
				width: width,
				height: height,
				color: hexPrefix + color,
				black: hexPrefix + hexToMonochrome(color),
				monochrome: monochrome
			});
			
		}
		if (!isBase64(source)) image.crossOrigin = "anonymous";
		image.src = source;
		
	}
	
	// Pass a base64-encoded image to the callback
	function imageToBase64(string, callback, width, height){ 
		decodeImage(string, callback, width, height); 
	}
	
	// Pass a canvas-element image to the callback
	function imageToCanvas(string, callback, width, height){ 
		decodeImage(string, callback, width, height, tagCanvas);
	}
	
	// Pass an img-element to the callback
	function imageToImg(string, callback, width, height){ 
		decodeImage(string, callback, width, height, tagImg);
	}	
	
	// Draw a base64-encoded jpeg-image from a data-string created by preview.encode() using canvas.
	function decodeImage(input, callback, width, height, element){
		
		// If a base64-encoded image is passed at this stage its expected to be optimised so it 
		// won’t affect its quality or resolution.
		if (isBase64(input)) return encodeImage(input, function(source){
			decodeImage(source, callback, element, width, height);
		}, false);
			
		// else...
		// Extract image data from the string parameter.
		var source = input.split(separateData);
		var data = source[1].match(/.{1,2}/g);
				
		// Extact meta data from the source prefix.
		var meta = getImageMeta(source[0]);
		if (!isNaN(width)){
			if (!isNaN(height)) meta.height = height;
			else meta.height = Math.round(meta.height * width / meta.width);
			meta.width = width;
		}
		
		var previewWidth  = keyIndex.indexOf(data.shift());
		var previewHeight = data.length / previewWidth; // calculate the preview’s height
		if (meta.monochrome) previewHeight = 0|previewHeight * 3; // compensate for the smaller data.length 
						
		// Prepare a html canvas.
		var canvas = createImage(tagCanvas, previewWidth, previewHeight);
		var imageData = createData(canvas, previewWidth, previewHeight);
		
		// Set the canvas image data.
		var index = 0, current = 0;
		if (meta.monochrome) for (var i = 0, length = imageData.data.length; i < length; i += 12){
			
			current = keyToChannel(data[index++]);
			var a = current[0], b = current[1], c = current[2];
			
			imageData.data[i  ] = a;
			imageData.data[i+1] = a;
			imageData.data[i+2] = a;
			imageData.data[i+3] = 255;
			
			imageData.data[i+4] = b; 
			imageData.data[i+5] = b;
			imageData.data[i+6] = b;
			imageData.data[i+7] = 255;
			
			imageData.data[i+8]  = c; 
			imageData.data[i+9]  = c
			imageData.data[i+10] = c;
			imageData.data[i+11] = 255;
			
		}
		else for (var i = 0, length = imageData.data.length; i < length; i += 4){
			
			current = keyToChannel(data[index++]);
			imageData.data[i  ] = current[0];
			imageData.data[i+1] = current[1];
			imageData.data[i+2] = current[2];
			imageData.data[i+3] = 255;
			
		}
		setData(canvas, imageData);
		
		// Load and redraw the canvas image to its given dimensions,  
		// then pass it to the callback as a base64 encoded jpeg-image.
		var image = createImage(tagImg);
		image.onload = function(){
			
			var result = drawImage(image, meta.width, meta.height);
			
			if (element !== tagCanvas) result = result.toDataURL(type);
			if (element){

				if (element === tagImg){
					element = createImage(element, meta.width, meta.height);
					element.src = result;
					result = element;
				}
				
				var className = classNames.base;
				if (meta.monochrome) className += " " + classNames.monochrome;
				result.className = className;
				
			}
			
			callback(result, meta);
			
		}
		image.src = canvas.toDataURL(type);

	}
	
	// Extract meta data from an encoded string.
	function getImageMeta(string, key){
		
		string = string.split(separateData)[0];
				
		var dimensions = string.substr(7).split(separateSize);
		var color = string.substr(1, 6);
		var monochrome = string[0] === monoPrefix;
		
		var object = {
			width:  dimensions[0],
			height: dimensions[1],
			color: hexPrefix + color,
			black: hexPrefix + hexToMonochrome(color),
			monochrome: monochrome
		};
				
		return typeof key === "string" ? object[key] : object;
		
	}

	
	// # Private functions
	// Utilities
	function isBase64(value){ return /^data:image/.test(value) }
	
	function limit(value, min, max){ return value < min ? min : value > max ? max : value }
	
	function resize(width, height, quality){
		
		if (quality !== false){
		
			quality = !isNaN(quality) && limit(quality, 1, 100) || 50;
			var resolution = quality / 1500;
			var treshold = quality * 1.28;
			
			var ratio = width / height;
			if (ratio > 1){ 
				width = Math.round(limit(width * resolution, 6, treshold));
				height = Math.round(width / ratio);
			}
			else {
				height =  Math.round(limit(height * resolution, 6, treshold));
				width = Math.round(height * ratio);
			}
		
		}
		return { width: width, height: height };
	
	}
		
	// Color
	function channelToKey(a, b, c){
		return map.hex[get(a) + get(b) + get(c)];
		function get(value){ return pool[Math.round(value / 17)] }
	}
	
	function keyToChannel(key){
		var hex = map.key[key];
		return [ get(hex[0]), get(hex[1]), get(hex[2]) ];
		function get(value){ return parseInt(value + value, 16) }
	}
	
	function getAverageColor(average, index){
		index = !isNaN(index) ? index : 1;
		var a = average[0] / index, b = average[1] / index, c = average[2] / index;
		return channelToHex(a) + channelToHex(b) + channelToHex(c);
	}
	
	function channelToHex(channel) {
		var hex = Math.round(channel).toString(16);
		return hex.length === 1 ? 0 + hex : hex;
	}
	
	function hexToMonochrome(hex){
		hex = hex.match(/.{1,2}/g);
		hex = parseInt(hex[0], 16) + parseInt(hex[1], 16) + parseInt(hex[2], 16)
		hex = channelToHex(Math.round(hex / 3));
		return hex + hex + hex;
	}
	
	// Document
	function createImage(tag, width, height){
		var image = document.createElement(tag);
		if (width) image.width = width;
		if (height) image.height = height;
		return image;
	}
	
	// Canvas
	function getContext(canvas){ return canvas.getContext("2d") }
	
	function getData(image, width, height){
		return getContext(drawImage(image, width, height)).getImageData(0, 0, width, height).data;
	}
	
	function setData(canvas, data){
		getContext(canvas).putImageData(data, 0, 0);
	}
	
	function createData(canvas, width, height){
		return getContext(canvas).createImageData(width, height);
	}
	
	function drawImage(image, width, height){
		var canvas = createImage(tagCanvas, width, height);
		getContext(canvas).drawImage(image, 0, 0, width,  height);
		return canvas;
	}
	
}(document);</script>
    <script>"use strict";
    !function(){ // generate demo page

        for (var i = 0, length = manifest.length; i < length; ++i){

            render(manifest[i], create("figure"), create("img"));

        }

        function render(image, figure, img){
            
            var timeout = limit(Math.round(Math.random() * 800), 100, 800);
            
            var color = reveal.meta(image.data, "black");
            figure.style.backgroundColor = color;
            figure.setAttribute("data-tint", color);

            reveal.canvas(image.data, function(canvas, color, width, height){

                img.width  = width;
                img.height = height;
               
                img.onload = function(){
                    setTimeout(function(){ img.classList.add("loaded") }, timeout);
                }
                img.src = image.src;

                figure.appendChild(img);
                figure.appendChild(canvas);

                document.body.appendChild(figure);

            });

        }
        function create(tag){ return document.createElement(tag) }
        function limit(n, min, max){ return n < min ? min : n > max ? max : n }

    }();        
    </script>
</body>
</html>